<!DOCTYPE html>
<html lang="en">
<head>
<link href="https://fonts.googleapis.com/css2?family=Sixtyfour&display=swap" rel="stylesheet">
<meta name="theme-color" content="black">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>pamdemo</title>

<!-- PWA Manifest -->
<link rel="manifest" href="./manifest.json">

<style>
  body {
    margin: 0;
    background: black;
    overflow: hidden;
  }
  canvas {
    display: block;
    border: 2px solid #00ffff;
    box-shadow: 0 0 20px #00ffff;
  }
</style>
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js')
    .then(() => console.log('Service Worker registered'))
    .catch(err => console.error('Service Worker registration failed:', err));
}
</script>
</head>
<body>
<canvas id="demoCanvas"></canvas>
<script>
const canvas = document.getElementById("demoCanvas");
const ctx = canvas.getContext("2d");
let time = 0;

// Responsive canvas
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// === BASIC 3D FUNCTIONS ===
function rotate3D(x, y, z, ax, ay, az) {
  let cosX = Math.cos(ax), sinX = Math.sin(ax);
  let y1 = y * cosX - z * sinX;
  let z1 = y * sinX + z * cosX;
  let cosY = Math.cos(ay), sinY = Math.sin(ay);
  let x2 = x * cosY + z1 * sinY;
  let z2 = -x * sinY + z1 * cosY;
  let cosZ = Math.cos(az), sinZ = Math.sin(az);
  let x3 = x2 * cosZ - y1 * sinZ;
  let y3 = x2 * sinZ + y1 * cosZ;
  return [x3, y3, z2];
}
function project3D(x, y, z, dist = 600) {
  const scale = dist / (dist + z);
  return { x: x * scale + canvas.width / 2, y: y * scale + canvas.height / 2 };
}

// === CUBE ===
const cubeVerts = [
  [-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],
  [-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]
];
const cubeEdges = [
  [0,1],[1,2],[2,3],[3,0],
  [4,5],[5,6],[6,7],[7,4],
  [0,4],[1,5],[2,6],[3,7]
];
function drawCube(ctx, cx, cy, size, ax, ay, az, color) {
  const verts = cubeVerts.map(v=>{
    const [x,y,z] = rotate3D(v[0]*size, v[1]*size, v[2]*size, ax, ay, az);
    const p = project3D(x, y, z);
    return {x:p.x - canvas.width/2 + cx, y:p.y - canvas.height/2 + cy};
  });
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.shadowBlur = 10;
  ctx.shadowColor = color;
  cubeEdges.forEach(e=>{
    const a=verts[e[0]], b=verts[e[1]];
    ctx.beginPath();
    ctx.moveTo(a.x,a.y);
    ctx.lineTo(b.x,b.y);
    ctx.stroke();
  });
}

// === HEAD ===
function drawHead(ctx, cx, cy, size, ax, ay, color) {
  const rings = 16, segments = 24;
  ctx.strokeStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 10;
  ctx.lineWidth = 1.5;
  for (let i=0; i<rings; i++){
    const lat1 = Math.PI * (-0.5 + i / rings);
    const lat2 = Math.PI * (-0.5 + (i+1) / rings);
    for (let j=0; j<segments; j++){
      const lon1 = 2*Math.PI * (j / segments);
      const lon2 = 2*Math.PI * ((j+1) / segments);
      const v1 = rotate3D(
        size*Math.cos(lat1)*Math.cos(lon1),
        size*Math.sin(lat1),
        size*Math.cos(lat1)*Math.sin(lon1),
        ax, ay, 0
      );
      const v2 = rotate3D(
        size*Math.cos(lat2)*Math.cos(lon2),
        size*Math.sin(lat2),
        size*Math.cos(lat2)*Math.sin(lon2),
        ax, ay, 0
      );
      const p1 = project3D(v1[0], v1[1], v1[2]);
      const p2 = project3D(v2[0], v2[1], v2[2]);
      ctx.beginPath();
      ctx.moveTo(p1.x - canvas.width/2 + cx, p1.y - canvas.height/2 + cy);
      ctx.lineTo(p2.x - canvas.width/2 + cx, p2.y - canvas.height/2 + cy);
      ctx.stroke();
    }
  }
}

// === PLASMA ===
function drawPlasma(ctx, t) {
  const w = canvas.width, h = canvas.height;
  const imgData = ctx.createImageData(w, h);
  const data = imgData.data;
  for (let y=0; y<h; y+=3) {
    for (let x=0; x<w; x+=3) {
      const v = Math.sin(x*0.01 + t*0.02) + Math.sin(y*0.01 - t*0.015) + Math.sin((x+y)*0.005 + t*0.01);
      const r = 128 + 127*Math.sin(v + t*0.02);
      const g = 128 + 127*Math.sin(v + 2);
      const b = 128 + 127*Math.sin(v + 4);
      for (let dx=0; dx<3; dx++){
        for (let dy=0; dy<3; dy++){
          const currX = x + dx;
          const currY = y + dy;
          if (currX < w && currY < h) {
             const i = ((currY)*w + (currX))*4;
             data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=255;
          }
        }
      }
    }
  }
  ctx.putImageData(imgData,0,0);
}

// === COPPER BARS ===
function drawCopperBars(ctx, t) {
  ctx.shadowBlur = 0;
  for (let i = 0; i < 3; i++) {
    const y =  canvas.height*0.8 + Math.sin(t*0.05 + i)*20;
    const grad = ctx.createLinearGradient(0, y, 0, y + canvas.height*0.03);
    grad.addColorStop(0, "#005599");
    grad.addColorStop(0.5, "#0088CC");
    grad.addColorStop(1, "#005599");
    ctx.fillStyle = grad;
    ctx.fillRect(0, y, canvas.width, canvas.height*0.05);
  }
}

// === SCROLLER ===
let scrollText = " 18 WELCOME FRIENDS TO THE SHOW THAT NEVER ENDS - PSYAMB EPISODE 151 - FEATURING SHPONGLE, PLASMA VOID, GLOBULAR AND MORE. SIT BACK AND RELAX AND ENJOY THE OLD SCHOOL VISUALS. SHOUT OUT TO REZ,FIXER,GMAN,BUMBLEWIZ AND THE DAYS OF YORE !! ";
let charWidths = [];
let fullTextWidth = 0;
let textX;
let scrollerInitialized = false;

function initScroller() {
    ctx.font = Math.floor(canvas.width*0.032)+"px 'Sixtyfour'";
    charWidths = scrollText.split("").map(ch => ctx.measureText(ch).width);
    fullTextWidth = charWidths.reduce((s,w)=>s+w, 0);
    textX = canvas.width;
    scrollerInitialized = true;
    if(fullTextWidth===0) fullTextWidth = scrollText.length*20;
}

function drawScroller(ctx, t){
    if(!scrollerInitialized) initScroller();

    const amp = canvas.height * 0.06;       // vertical wave amplitude
    const baseSpeed = canvas.width * 0.002; // base horizontal speed
    const baselineY = canvas.height * 0.8;  // base Y position
    const periodFactor = 4;                  // number of waves across the canvas
    const velocityFactor = 1;             // controls how much speed varies with slope

    ctx.save();
    ctx.textBaseline = "top";
    ctx.font = Math.floor(canvas.width*0.032) + "px 'Sixtyfour'";
    ctx.shadowBlur = 0;

    let drawX = textX;

    for(let i = 0; i < scrollText.length; i++){
        const ch = scrollText[i];
        const charWidth = charWidths[i];

        // compute wave
        const wavePhase = (drawX / canvas.width) * Math.PI * 2 * periodFactor + t*0.05;
        const y = baselineY + Math.sin(wavePhase) * amp;

        // derivative of sine for slope-based velocity
        const slope = Math.cos(wavePhase);
        const speed = baseSpeed * (1 + slope * velocityFactor);

        // color wave synced to X position
       // === Bright rainbow color wave ===
const phase = drawX * 0.01 + t * 0.05;
const r = Math.round(200 + 55 * Math.sin(phase));       // 200â€“255 range
const g = Math.round(200 + 55 * Math.sin(phase + 2));
const b = Math.round(200 + 55 * Math.sin(phase + 4));
ctx.fillStyle = `rgb(${r},${g},${b})`;

        ctx.fillText(ch, drawX, y);

        // move X by width + variable speed
        drawX += charWidth   + speed+10;
    }

    // move the whole scroller
    textX -= baseSpeed;
    if(textX < -fullTextWidth) textX = canvas.width;

    ctx.restore();
}



// === ROTATING TEXT ===
function drawRotatingText(ctx,t){
    const textToDraw="PSYAMB";
    ctx.save();
    const scale = canvas.width/1920;
    ctx.font = Math.floor(52*scale)+"px 'Sixtyfour'";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    const centerX = canvas.width/2;
    const centerY = canvas.height*0.15;
    const rotX = Math.sin(t*0.04)*0.3;
    const rotY = Math.sin(t*0.03)*0.3;
    const rotZ = Math.sin(t*0.02)*0.5;
    ctx.translate(centerX,centerY);
    ctx.rotate(rotZ);
    const offsetX = Math.sin(rotY)*50*scale;
    const offsetY = Math.sin(rotX)*20*scale;
    ctx.fillStyle="#ffffff";
    ctx.fillText(textToDraw,offsetX,offsetY);
    ctx.restore();
}

// === MAIN LOOP ===
function animate(){
    if(!scrollerInitialized) initScroller();
    ctx.clearRect(0,0,canvas.width,canvas.height);
  

    drawPlasma(ctx,time);
    drawCopperBars(ctx,time);

    const scale = canvas.width/1920;
    drawCube(ctx, canvas.width*0.3, canvas.height/2, 100*scale, time*0.02, time*0.03, 0, "#00ffff");
    drawCube(ctx, canvas.width*0.7, canvas.height/2, 100*scale, -time*0.02, -time*0.03, 0, "#ff00ff");
    drawHead(ctx, canvas.width/2, canvas.height/2, 150*scale, time*0.015, time*0.02, "#ffff00");

    drawScroller(ctx,time);
    drawRotatingText(ctx,time);

    ctx.strokeStyle="red";
    ctx.lineWidth=2;
    ctx.strokeRect(0,0,canvas.width,canvas.height);

    time += 0.3;
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>













































